<html>
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" >
  <link rel="stylesheet" type="text/css" href="../style.css" />
  <title>Class 5</title>

</head>
<body>
<div class="page">

<h2> Class 5 </h2>


<h3>Regular expressions</h3>

You got a bit familiar with regular expressions in the <a href="01.html">tutorial</a> on the command line with <tt>sed</tt> and
<tt>grep</tt>. If you enjoyed that, you will be pleasantly surprised that it's also possible to use
regular expressions in Python! There is a nice tutorial on the Python site <a href="https://docs.python.org/3/library/re.html">here</a>,
but here are the highlights:

You can find a matching part of a string using <tt>search()</tt>:

<pre>
>>> import re 

>>> s = 'Привет мир!'

>>> re.search(r'м[а-я]+', s)
</pre>

If you want to replace parts of a string, you can use <tt>sub()</tt> which works a bit like <tt>sed</tt>:

<pre>
>>> re.sub('[а-я]', 'x', s)
'Пxxxxx xxx!'
</pre>

<h3>Libraries in Python</h3>

<div style="background-color:red; width:100%;text-align:center"><span style="color: white"><b>TODO: Expand</b></span></div>

<!--<h4> <tt>numpy</tt> </h4> -->
<!--<h4> ElementTree </h4> -->
<!--<h4> </h4> -->

<h3>Screenscraping</h3>

Screenscraping (or web scraping) is the task of pulling human-readable data from the web and turning it 
into machine-readable form. There are two main components, the first is <em>crawling</em> which means
downloading the pages you are interested in. The second is <em>scraping</em> which means getting the 
information out of those pages. We're going to flip things around and start with the second first.

Run this command:

<pre>
$ wget -q -O - "http://ru.wiktionary.org/wiki/страх" 
</pre>

The output is pretty terrifying right ? A tonne of HTML code, very difficult to find the structure or data. But if 
we go to the page <a href="http://ru.wiktionary.org/wiki/страх">страх</a> there is a lot of useful data. What kind
of data might we be interested in ? 

<ul>
<li> Stem </li>
<li> Inflection table </li>
<li> Zaliznjak code </li>
<li> Definitions </li>
<li> Translations </li>
<li> Pronunciation </li>
<li> ... </li>
</ul>

Let's start with a simple exercise to extract the stem, the pronunciation and the Zaliznjak code. Download
the page and save it to a file called <tt>страх.html</tt> with <tt>wget</tt> or <tt>curl</tt>. Now look
through the HTML and find the lines where the information you are looking for is.

Here is the line with the stem,

<pre>
&lt;p&gt;Корень: &lt;b&gt;-страх-&lt;/b&gt;.&lt;/p&gt;
</pre>

Here is the line with the pronunciation,

<pre>
&lt;li&gt;&lt;a href="https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D0%B6%D0%B4%D1%83%D0%BD%D0%B0%D1%80%D0%BE%D0%B4%D0%BD%D1%8B%D0%B9_%D1%84%D0%BE%D0%BD%D0%B5%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%B0%D0%BB%D1%84%D0%B0%D0%B2%D0%B8%D1%82" class="extiw" title="w:Международный фонетический алфавит"&gt;МФА&lt;/a&gt;: ед.&amp;#160;ч.&amp;#160;[&lt;span class="IPA" style="white-space: nowrap;"&gt;strax&lt;/span&gt;]
</pre>

And here is the line with the Zaliznjak code,

<pre>
&lt;p&gt;&lt;a href="/wiki/%D1%81%D1%83%D1%89%D0%B5%D1%81%D1%82%D0%B2%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5" title="существительное"&gt;Существительное&lt;/a&gt;, неодушевлённое, мужской род, 2-е &lt;a href="/wiki/%D1%81%D0%BA%D0%BB%D0%BE%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5" title="склонение"&gt;склонение&lt;/a&gt; (тип склонения 3a по &lt;a href="/wiki/%D0%92%D0%B8%D0%BA%D0%B8%D1%81%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C:%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_%D1%81%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8F_%D0%97%D0%B0%D0%BB%D0%B8%D0%B7%D0%BD%D1%8F%D0%BA%D0%B0" title="Викисловарь:Использование словаря Зализняка"&gt;классификации А.&amp;#160;А.&amp;#160;Зализняка&lt;/a&gt;).&lt;/p&gt;
</pre>

We might decide that all of this would be a lot easier to process if we didn't have the HTML code in the 
way... that might not always be the case. But we could try a simple function like the following 
to get rid of (most of) the HTML:

<pre>
def strip_html(h):
	o = ''
	inTag = False
	for c in h: 
		if c == '<':
			inTag = True
			continue
		if c == '>':
			inTag = False
			continue
		if not inTag:
			o = o + c
	return o	
</pre>

Now let's see what we get:

<pre>
Корень: -страх-.
</pre>

<pre>
МФА: ед.&amp;#160;ч.&amp;#160;[strax]
</pre>

<pre>
Существительное, неодушевлённое, мужской род, 2-е склонение (тип склонения 3a по классификации А.&amp;#160;А.&amp;#160;Зализняка).
</pre>

<div style="background-color:red; width:100%;text-align:center"><span style="color: white"><b>TODO: Expand</b></span></div>


<h3>Unigram tagger</h3>

<p>
A unigram tagger works by assiging the most frequent tag seen for a given
surface form. It may additionally <em>back-off</em> to the most frequent
tag in general. Our unigram language model has all of this information, we 
just need to apply it to our input stream.
</p>

<p>
The first thing your program will need to do is load the language model and 
calculate the most frequent tag per word and most frequent tag in general. You
can use a <tt>dict</tt> for the word → tag mapping and a simple variable
for the most frequent tag.
</p>

Example input:

<pre>
# sent_id = 482
# text = Часть его положений отменена Конституционным судом в 2013 году.
1	Часть	_	_	_	_	_	_	_	_
2	его	_	_	_	_	_	_	_	_
3	положений	_	_	_	_	_	_	_	_
4	отменена	_	_	_	_	_	_	_	_
5	Конституционным	_	_	_	_	_	_	_	_
6	судом	_	_	_	_	_	_	_	_
7	в	_	_	_	_	_	_	_	_
8	2013	_	_	_	_	_	_	_	_
9	году	_	_	_	_	_	_	_	_
10	.	_	_	_	_	_	_	_	_

</pre>

Output:

<pre>
# sent_id = 482
# text = Часть его положений отменена Конституционным судом в 2013 году.
1	Часть	_	NOUN	_	_	_	_	_	_
2	его	_	NOUN	_	_	_	_	_	_
3	положений	_	NOUN	_	_	_	_	_	_
4	отменена	_	NOUN	_	_	_	_	_	_
5	Конституционным	_	NOUN	_	_	_	_	_	_
6	судом	_	NOUN	_	_	_	_	_	_
7	в	_	ADP	_	_	_	_	_	_
8	2013	_	NOUN	_	_	_	_	_	_
9	году	_	NOUN	_	_	_	_	_	_
10	.	_	PUNCT	_	_	_	_	_	_
</pre> <!-- 70% correct -->

<h3> Questions </h3>

<ul>
  <li> How accurate is the tagger ?</li>
  <li> How could you improve performance without incorporating context ...</li>
  <ul>
    <li> using Python string functions ? </li>
    <li> using regular expressions ? </li>
  </ul>
  <li> Could you store other single-word features in your unigram model ? Which features might you like to store ?</li>
</ul>

</div>

</body>
</html>
